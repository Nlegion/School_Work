# Если у вас есть много данных, то можно попытаться описать их какой-либо функцией. Если такую функцию найти, то можно предугадать тренд изменения поведения ваших данных в будущем. И много еще полезного несет знание такой функции.
#
# Напишите функцию trend(), определяющую, подходит ли некоторая зависимость к имеющимся данным.
#
# Функция принимает произвольное число кортежей (значение аргумента x, значение функции), и то и другое – вещественные числа. Также функция принимает произвольное число именованных аргументов – это функции для проверки. Если какая-то из функций настолько хорошо описывает ваши данные, что отклонение всех результатов при подстановке x в функцию не превышает 0.01, то нужно вернуть имя именованного аргумента, в который записана эта функция. Если ничего подходящего не нашлось, вернуть None.
#
# Пример 1
# Ввод	Вывод
# data = [(0, 0), (-1.0, 1.001), (3.0, 8.999), (-2.0, 4.0)]
# functions = {"line": lambda x: 3 * x,
#              "square": lambda x: x ** 2,
#              "cube": lambda x: 0.5 * x ** 3}
# print(trend(*data, **functions))
# square

def trend(*args, **kwargs):
    sp_keys = list(kwargs.keys())
    b = []
    a = list(map(lambda x: list(x), args))
    for i in range(len(a)):
        b.append(a[i][0])
    key = 0
    for i in kwargs.values():
        c = list(map(i, b))
        d = []
        for j in range(len(a)):
            d.append(a[j][1] - c[j])
        kol = 0
        for x in range(len(d)):
            if abs(d[x]) <= 0.01:
                kol += 1
        if kol == len(args):
            return sp_keys[key]
        key += 1
    return None
